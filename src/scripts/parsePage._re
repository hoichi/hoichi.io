module FrontMatter = {
	[@bs.deriving.abstract]
	type parseResult = {.
		"body": string,
		[@bs.optional] "attributes": Js.Json.t,
	};

	// todo: make sure that body and
	[@bs.module] external parse : string => parseJsResult = "front-matter";
}

module Markdown = {
	// hack: types
	// Ideally, FrontMatter should return a body of SomeMarkup.t
	[@bs.module "markdown-it"] external render : string => string = "render";

	type plugin('attr) = string => 'attr => string;
	[@bs.mobule] external prism : plugin(unit => unit) = "prism";
	[@bs.module "markdown-it"] external use : plugin('a) => unit = "use";
}

[@bs.module] external slugify : string => string = "slugify";

import { extract1stHtmlParagraph, constructPageUrl } from './utils';

// init markdown-it
const md = markdownIt({
  "breaks": true,
  "html": true,
  "typographer": true,
  "quotes": '«»„“',
});
md.use(prism, () => void 0);

function parseSource(page: SourceFile) {
  const { path, rawContent } = page;

  const { body = rawContent, attributes = {} } = FrontMatter.parse(rawContent);

  return {
    content: md.render(body),
    meta: attributes,
    path
  }
}

function parsePost(page: SourceFile): Post {
  const { path, content, meta } = parseSource(page);

  const result = {
    // id is crucial
    id: path.full,
    // here’s some defaults
    title: 'Untitled',
    date: new Date(),
    //
    published: true,
    category: path.dir || '',
    //
    content,
    excerpt: extract1stHtmlParagraph(content),

    // and here we override them with the yfm data
    // not too lazy, yes
    ...meta,

    tags: (meta['tags'] || []).map(tag => ({
      title: tag,
      slug: slugify(tag),
    })),
  };

  return {
    kind: 'post',
    ...result,
    // we need meta for constructPageUrl
    // fixme: it’s all hacky and brittle
  };
}

function parseStaticPage(page: SourceFile): StaticPage {
  const { path, content, meta } = parseSource(page);

  if (!meta['title']) throw Error(`No title found for ${path.full}`);

  return {
    kind: 'static',
    content,
    template: 'single',
    ...meta,
  }
}


export { parsePost, parseStaticPage };
